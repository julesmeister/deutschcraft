/**
 * useWebRTCMedia Hook (Refactored)
 * Simplified WebRTC implementation using modular peer and signal management
 */

import { useEffect, useRef, useState, useCallback } from 'react';
import {
  registerParticipant,
  unregisterParticipant,
  updateMuteStatus,
  listenForParticipants,
  sendOffer,
  sendAnswer,
  listenForSignals,
  type SignalMessage,
} from './webrtc/firebaseSignaling';
import {
  createPeerConnection,
  setupAudioPlayback,
  cleanupPeerConnection,
  type PeerConnection,
} from './webrtc/peerManager';
import type { MediaParticipant, UseWebRTCMediaOptions } from './webrtc/types';

export function useWebRTCMedia({
  roomId,
  userId,
  userName,
  enableVideo = false,
  onError,
}: UseWebRTCMediaOptions) {
  const [isVoiceActive, setIsVoiceActive] = useState(false);
  const [isVideoActive, setIsVideoActive] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [participants, setParticipants] = useState<MediaParticipant[]>([]);
  const [audioStreams, setAudioStreams] = useState<Map<string, MediaStream>>(new Map());
  const [videoStreams, setVideoStreams] = useState<Map<string, MediaStream>>(new Map());
  const [audioAnalysers, setAudioAnalysers] = useState<Map<string, AnalyserNode>>(new Map());

  const localStreamRef = useRef<MediaStream | null>(null);
  const peerConnectionsRef = useRef<Map<string, PeerConnection>>(new Map());
  const audioContextRef = useRef<AudioContext | null>(null);
  const previousRoomIdRef = useRef<string | null>(null);
  const signalUnsubscribeRef = useRef<(() => void) | null>(null);
  const participantsUnsubscribeRef = useRef<(() => void) | null>(null);
  const isMediaActiveRef = useRef<boolean>(false);

  // Reset state when room changes
  useEffect(() => {
    if (previousRoomIdRef.current && previousRoomIdRef.current !== roomId) {
      console.log('[WebRTC Media] Room changed, resetting state');
      cleanup();
    }
    previousRoomIdRef.current = roomId;
  }, [roomId]);

  // Cleanup function
  const cleanup = useCallback(() => {
    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach((track) => track.stop());
      localStreamRef.current = null;
    }

    peerConnectionsRef.current.forEach((peer) => {
      cleanupPeerConnection(peer);
    });
    peerConnectionsRef.current.clear();

    if (audioContextRef.current) {
      audioContextRef.current.close();
      audioContextRef.current = null;
    }

    if (signalUnsubscribeRef.current) {
      signalUnsubscribeRef.current();
      signalUnsubscribeRef.current = null;
    }

    if (participantsUnsubscribeRef.current) {
      participantsUnsubscribeRef.current();
      participantsUnsubscribeRef.current = null;
    }

    setIsVoiceActive(false);
    setIsVideoActive(false);
    setIsMuted(false);
    setParticipants([]);
    setAudioStreams(new Map());
    setVideoStreams(new Map());
    setAudioAnalysers(new Map());
    isMediaActiveRef.current = false;
  }, []);

  // Handle received track
  const handleTrackReceived = useCallback(
    (remoteUserId: string, stream: MediaStream, hasAudio: boolean, hasVideo: boolean) => {
      const peer = peerConnectionsRef.current.get(remoteUserId);
      if (!peer) return;

      peer.stream = stream;

      if (hasAudio) {
        setAudioStreams((prev) => {
          const updated = new Map(prev);
          updated.set(remoteUserId, stream);
          return updated;
        });

        const audioSetup = setupAudioPlayback(stream, audioContextRef.current);
        peer.audioElement = audioSetup.audioElement;
        peer.source = audioSetup.source;
        peer.analyser = audioSetup.analyser;
        peer.gainNode = audioSetup.gainNode;

        if (audioSetup.analyser) {
          setAudioAnalysers((prev) => {
            const updated = new Map(prev);
            updated.set(remoteUserId, audioSetup.analyser!);
            return updated;
          });
        }
      }

      if (hasVideo) {
        setVideoStreams((prev) => {
          const updated = new Map(prev);
          updated.set(remoteUserId, stream);
          return updated;
        });
      }
    },
    []
  );

  // Handle connection state change
  const handleConnectionStateChange = useCallback((remoteUserId: string, state: RTCPeerConnectionState) => {
    if (state === 'failed' || state === 'disconnected') {
      console.error('[WebRTC Media] Connection failed/disconnected:', remoteUserId);
      peerConnectionsRef.current.delete(remoteUserId);

      setAudioStreams((prev) => {
        const updated = new Map(prev);
        updated.delete(remoteUserId);
        return updated;
      });

      setVideoStreams((prev) => {
        const updated = new Map(prev);
        updated.delete(remoteUserId);
        return updated;
      });

      setAudioAnalysers((prev) => {
        const updated = new Map(prev);
        updated.delete(remoteUserId);
        return updated;
      });
    }
  }, []);

  // Create peer connection helper
  const createPeer = useCallback(
    (remoteUserId: string): RTCPeerConnection => {
      const pc = createPeerConnection({
        roomId,
        userId,
        remoteUserId,
        localStream: localStreamRef.current,
        audioContext: audioContextRef.current,
        onTrackReceived: handleTrackReceived,
        onConnectionStateChange: handleConnectionStateChange,
      });

      peerConnectionsRef.current.set(remoteUserId, { pc, stream: null });
      return pc;
    },
    [roomId, userId, handleTrackReceived, handleConnectionStateChange]
  );

  // Handle incoming signals
  const handleSignal = useCallback(
    async (signal: SignalMessage) => {
      const { type, fromUserId, data } = signal;

      console.log('[WebRTC Media] Processing signal:', type, 'from:', fromUserId);

      try {
        let peer = peerConnectionsRef.current.get(fromUserId);
        if (!peer) {
          const pc = createPeer(fromUserId);
          peer = { pc, stream: null };
        }

        const { pc } = peer;

        switch (type) {
          case 'offer':
            console.log('[WebRTC Media] Received offer from:', fromUserId);
            await pc.setRemoteDescription(new RTCSessionDescription(data));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await sendAnswer(roomId, userId, fromUserId, answer);
            break;

          case 'answer':
            console.log('[WebRTC Media] Received answer from:', fromUserId);
            await pc.setRemoteDescription(new RTCSessionDescription(data));
            break;

          case 'ice-candidate':
            if (data) {
              await pc.addIceCandidate(new RTCIceCandidate(data));
            }
            break;

          case 'participant-joined':
            if (userId < fromUserId && isMediaActiveRef.current) {
              setTimeout(async () => {
                const newPeer = peerConnectionsRef.current.get(fromUserId);
                if (!newPeer) {
                  const pc = createPeer(fromUserId);
                  const offer = await pc.createOffer();
                  await pc.setLocalDescription(offer);
                  await sendOffer(roomId, userId, fromUserId, offer);
                }
              }, Math.random() * 500);
            }
            break;

          case 'participant-left':
            const leavingPeer = peerConnectionsRef.current.get(fromUserId);
            if (leavingPeer) {
              cleanupPeerConnection(leavingPeer);
              peerConnectionsRef.current.delete(fromUserId);

              setAudioStreams((prev) => {
                const updated = new Map(prev);
                updated.delete(fromUserId);
                return updated;
              });

              setVideoStreams((prev) => {
                const updated = new Map(prev);
                updated.delete(fromUserId);
                return updated;
              });

              setAudioAnalysers((prev) => {
                const updated = new Map(prev);
                updated.delete(fromUserId);
                return updated;
              });
            }
            break;
        }
      } catch (error) {
        console.error('[WebRTC Media] Error handling signal:', type, error);
      }
    },
    [roomId, userId, createPeer]
  );

  // Start media (voice and optionally video)
  const startMedia = useCallback(
    async (withVideo: boolean = false) => {
      try {
        console.log('[WebRTC Media] Starting media...', { roomId, userId, userName, withVideo });

        if (!roomId || !userId) {
          throw new Error('No room ID or user ID provided');
        }

        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 48000,
          },
          video: withVideo
            ? {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                facingMode: 'user',
                frameRate: { ideal: 30 },
              }
            : false,
        });

        localStreamRef.current = stream;
        setIsVoiceActive(true);
        setIsVideoActive(withVideo);
        setIsMuted(false);
        isMediaActiveRef.current = true;

        stream.getTracks().forEach((track) => {
          track.enabled = true;
        });

        if (!audioContextRef.current) {
          audioContextRef.current = new AudioContext();
        }

        await registerParticipant(roomId, userId, userName, false);

        signalUnsubscribeRef.current = listenForSignals(roomId, userId, handleSignal);

        participantsUnsubscribeRef.current = listenForParticipants(roomId, userId, (participants) => {
          setParticipants(participants.map((p) => ({ ...p, isVideoEnabled: false })));

          participants.forEach((participant) => {
            const existingPeer = peerConnectionsRef.current.get(participant.userId);
            if (!existingPeer && userId < participant.userId) {
              setTimeout(async () => {
                const pc = createPeer(participant.userId);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await sendOffer(roomId, userId, participant.userId, offer);
              }, Math.random() * 1000);
            }
          });
        });

        console.log('[WebRTC Media] ✅ Media started successfully');
      } catch (error) {
        console.error('[WebRTC Media] ❌ Failed to start media:', error);
        setIsVoiceActive(false);
        setIsVideoActive(false);
        onError?.(error as Error);
        throw error;
      }
    },
    [roomId, userId, userName, handleSignal, onError, createPeer]
  );

  const startVoice = useCallback(async () => {
    await startMedia(false);
  }, [startMedia]);

  const startVideo = useCallback(async () => {
    await startMedia(true);
  }, [startMedia]);

  const stopMedia = useCallback(async () => {
    console.log('[WebRTC Media] Stopping media...');
    if (roomId && userId) {
      await unregisterParticipant(roomId, userId);
    }
    cleanup();
    isMediaActiveRef.current = false;
  }, [roomId, userId, cleanup]);

  const stopVoice = useCallback(async () => {
    await stopMedia();
  }, [stopMedia]);

  const stopVideo = useCallback(async () => {
    await stopMedia();
  }, [stopMedia]);

  const toggleMute = useCallback(async () => {
    if (!localStreamRef.current) return false;

    const audioTracks = localStreamRef.current.getAudioTracks();
    if (audioTracks.length === 0) return false;

    const newMutedState = !isMuted;
    audioTracks.forEach((track) => {
      track.enabled = !newMutedState;
    });

    setIsMuted(newMutedState);
    await updateMuteStatus(roomId, userId, userName, newMutedState);

    return newMutedState;
  }, [isMuted, roomId, userId, userName]);

  const toggleVideo = useCallback(async () => {
    if (!localStreamRef.current) return false;

    const videoTracks = localStreamRef.current.getVideoTracks();

    if (videoTracks.length === 0) {
      try {
        const videoStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
            facingMode: 'user',
            frameRate: { ideal: 30 },
          },
        });

        videoStream.getVideoTracks().forEach((track) => {
          localStreamRef.current!.addTrack(track);
          peerConnectionsRef.current.forEach((peer) => {
            peer.pc.addTrack(track, localStreamRef.current!);
          });
        });

        setIsVideoActive(true);
        return true;
      } catch (error) {
        console.error('[WebRTC Media] Failed to start video:', error);
        onError?.(error as Error);
        return false;
      }
    }

    const newVideoState = !isVideoActive;
    videoTracks.forEach((track) => {
      track.enabled = newVideoState;
    });

    setIsVideoActive(newVideoState);
    return newVideoState;
  }, [isVideoActive, onError]);

  const getLocalStream = useCallback(() => {
    return localStreamRef.current;
  }, []);

  useEffect(() => {
    return () => {
      if (localStreamRef.current) {
        stopMedia();
      }
    };
  }, [stopMedia]);

  return {
    isVoiceActive,
    isVideoActive,
    isMuted,
    participants,
    audioStreams,
    videoStreams,
    audioAnalysers,
    localStream: getLocalStream(),
    startVoice,
    startVideo,
    stopVoice,
    stopVideo,
    stopMedia,
    toggleMute,
    toggleVideo,
  };
}
